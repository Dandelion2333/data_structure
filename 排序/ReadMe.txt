此项目的目的：
    1、学习数据结构中的十种排序算法，具体涉及到算法的原理、算法的实现方法、算法的相关知识
    2、使用Python作为实现工具，进一步加深对Python的学习

项目开始的时间：
    2020.02.04  周二

项目进度：
2020.02.04  周二    （V1.0）
    1、建立基本数据结构，数组数据形成
    2、实现选择排序

2020.02.08  周六
    1、学习、实现快速排序
    2、学习、实现插入排序

2020.02.09  周日    （V2.0）
    1、学习、实现希尔排序
    2、增加时间复杂度可视化，把排序中的交换与比对的次数打印可视
    3、增加排序算法的运行时间记录功能
    4、学习、实现冒泡排序
    5、添加十种排序的详细信息图片

2020.02.12  周三
    1、学习、并用不同的方式实现堆排序
    2、深入理解堆排序，通过看网上的教程，自己用代码实践，与大佬F探讨、听从其教诲
    3、优化冒泡排序

2020.02.13  周四
    1、学习、并实现归并排序
    2、深入理解递归的精髓，使用的场景
    3、通过学习递归，进一步加深对快速排序算法的理解。

名词定义：
    1、稳定性： 假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，
        ri=rj，排序之后仍然ri=rj。进一步讲，排序前ri在rj之前，而在排序后的序列中，ri仍在rj之前，则称这种排序算法是稳定的；
        否则称为不稳定的。

算法原理及属性：
    1、选择排序
        1、原理
            每次都选择数组中最小的数，将其依次从第零个放入，直到最后。
        2、属性
            时间复杂度：由于每次都会遍历一遍数组，选出最小的数据。假设有n个数据，则总共需要比对n²。也就是平均复杂度为n²，同理最坏情况下也是如此。
                那么，最好的情况呢？其实也是，原因为，即使是顺序排列，按照原理可知，也需要两个循环。
            空间复杂度：不会暂用其他空间，只要本数组即可，即为1。
            稳定性：为不稳定。
                用数组5,8,5,2,9的例子解释。第一次，选择2为最小值，其与第零位的5交换位置，那么，排序后两个五的相对位置与排序前的
                    相对位置就产生了变化。即为不稳定的

    2、快速排序
        1、原理
            选择第一个数作为基数，比它小的放左边，比它大的放右边，完成一轮对比之后，以基数作为分界线，左右两边两组数据，再用同样的方法排序
                直到最终排序完成
			基数的位置不用动，先从最右边开始，找到第一个比基数小的数，然后从左边开始，找到第一个比基数大的数，然后交换两个数的位置。知道左边的计数大于等于右边的计数器
        2、属性
            时间复杂度：平均的时间复杂度为O(nlogn)，最好的情况也是如此，最坏的情况是n²
            空间复杂度：由于用到了递归，所以，空间复杂度为：O(nlogn)
            稳定性：为不稳定
                这个很好理解，就拿两个相同的数来说，在比对、交换的过程中，他们之间的相对位置肯定会被改变。
        3、其他
            快速排序的理论核心在于与基数的比对，然后产生两组特别数据，然后对这两组是数据进行与上个步骤相同的处理
            既然都为相同操作，那么就用用到递归，在代码上要特别注意递归的使用，所以引入begin与end是非常好的操作。
			引入begin与end的好处是，begin总是记录基数，end记录此次排序的末尾数
        4、稳定性
            为不稳定排序：原因同选择排序一样，在交换的过程中会改变两个数据的相对位置。

    3、插入排序
        1、原理
            可以看作是把一个数据插入到一个有序数据中，一般都是从后面插入。
            从第一个开始，它已经是有序数据了，将他与第二个进行比较，假如大于后者，则把后者插入到前面。
			插入方式理解：对于第二层循环(由小到大排序)，遍历已经排好部分(例如1,5,9,12)，从12开始往前寻找合适的位置插入
        2、属性 
            时间复杂度：由于它也是两层循环，所以平均复杂度肯定是n²，最坏的情况也是如此。最好的情况则是排好顺序的数据，则第二层循环用不上
                不需要移动数据，所以为n
            空间复杂度：不会暂用其他空间，只要本数组即可，即为O(1)。
            稳定性：为稳定 
                因为插入的原则是，当两个数据相同时，不用处理，也就是不用插入到前一个数据的前面，那么他们的相对位置就没有任何变化。
        3、其他
            我在实现插入排序时，把问题复杂化了，用了很多变量来表示，结果越来越乱。解决问题的关键在于要插入的数据与它的编号。然后根据编号
                向左移动，此时的移动用一个while循环做，判断的条件是插入数据大于它的前一个数据。
    4、希尔排序
        1、原理 
            插入排序的进阶版。
            按照一定的间隔h,选取一个数据，组成一组新的数组，相应的会产生h组数据，然后对这些数组使用插入排序。
            然后，使用二分之h作为间隔，重复上述步骤，直到h等于1。这种排序方式为希尔排序
        2、属性
            时间复杂度：平均时间复杂度为O(n的1.3次方)，最后的情况是n，最差的情况是n²
            空间复杂度：不会暂用其他空间，只要本数组即可，即为1。
            稳定性：为不稳定
                这个很好理解，按照一定的间隔取了数据之后，原来的相对关系肯定被改变了。
        3、其他
            while leftCnt > (begin - gap) and ShMatrix[leftCnt] > insertValue:
            这句特别关键，leftCnt大于的数值是从开始的位置往左边移动对应间隔的距离。

    5、冒泡排序
        1、原理
            从第一二个数开始比较，较大的数放后面，然后再第二三个数进行比较，较大的数放后面，一直比较到最后一个数
            所以，数组中最大的数就像冒泡的样子，移到了最后。这便是第一轮操作。
            同理，第二轮操作与第一轮一模一样。
        2、属性 
            时间复杂度：由于有两层循环，所以，平均时间复杂度为O(n²)，最坏的情况也是如此
                最好的情况是已经排好序了，所以只要一层循环就够了。
            空间复杂度：不会暂用其他空间，只要本数组即可，即为1。
            稳定性：为稳定
                因为在冒泡的过程中，是两者进行大小比对，不会改变数据的相对位置
        3、其他
            1、冒泡排序相对简单，但是可以参考别的大神用非常简洁的方式实现这套算法。
            2、内层循环与外层循环要相互“独立”，互相直接尽量不要牵扯。这样的目的是使算法更简单明了，也不易出错
            3、用外层循环的次数控制内层循环
        4、特别补充
            1、对于一个已经排好序的数组来说，时间复杂度为n。因为，冒泡的性质决定，当第一轮比对过后，没有数据交换，第二层循环就不会执行
    
    6、堆排序
        1、原理
            1、使用完全二叉树作为基本堆结构。(完全二叉树的定义为：除了最后一层外，其他层都被完全填满，且最后一层是想向左对齐)
            2、构建一个大根堆(升序用大根堆，降序用小根堆)
                构建的方法是，找到最后一个非叶子节点，将其作为父节点，并于子节点做比较，取最大的数值放置父节点。
                    然后再使用倒数第二个非叶子节点，做同样的操作，直到遍历到根节点。
                补充：倒数第一个非叶子节点为：(length/2)-1。 
                再补充：由于我们要构建大根堆，所以，每一个父节点相对于子节点来说，都是他们之间的较大值。
                    所以，我们在构建的过程中，要特别注意当一个父节点产生变化时，一定要与其子节点再次比较。确保都是大根堆
            3、替代根节点。经过步骤二，根节点已经是数组中的最大值了，所以，我们把最大值放数组的最后面。所以，把数组的最后一个数与第一个数交换位置。
            4、调整大根堆（与第二步的构建大根堆时一样的），调整后必须满足大根堆的性质。
				从根节点（此时的根节点是刚刚用数组的最后一个数替换的）开始，把父节点与子节点比较，取其较大的值。同理，子节点的数值变了，于是需要继续往下调整。		  
            5、重复3、4步骤，特别注意的是，第二次替换的时候，用倒数二个数。
				循环停止的条件为，循环到正数第二个，也就是重复了数组元素总个数减一次。
        2、属性
            时间复杂度：平均、最好、最差的时间复杂度都为O(nlogn)。这么说来，他还是很稳定的嘛
            空间复杂度：由于在运算过程中使用的空间都为常数量级，所以空间复杂度为1
        3、其他 
            1、特别注意再补充的部分。
            2、理解堆排序的原理

    7、归并排序
        1、原理
            1、把一个数组分割成len(arr)个单独的数组，每个数组都是一个元素
            2、把这些数组看成是已经排好序的有序数组。
            3、用递归的思想对有序数组排序，最终把整个数组排好序
        2、属性
            1、时间复杂度：由于递归的深度为log2的n，遍历一次为n，所以，无论情况好坏，都是nlog2的n
            2、空间复杂度：由于要用到额外的空间，所以其复杂度为n
            3、稳定性：通过它的原理可知，他是稳定的。
        3、其他
            1、注意递归的写法，这个很神奇。
        
    8、计数排序
        1、原理
            1、找出待排序数据中的最大值，命名为max
            2、新建一个数组，下标最大为max
            3、遍历待排序数组，把数据对应为新数组的下标，每遇到一个则加一
            4、遍历完之后，新数组中会从小到大记录数据的个数
            5、打印新数组中非空的元素
        2、属性
            1、时间复杂度为：n+k，n为遍历待排序数组的时长，k为遍历新数组的时长，由于它的原理可知，最坏与最好都是n+k
            2、空间复杂度为：n+k，因为自身需要一个空间N，额外再需要一个空间K
            3、稳定性：她是稳定的
        3、其他
            1、无
    9、桶排序
        1、原理
            1、把整个数组的放入若干个桶中
            2、然后对桶内元素进行排序
            3、然后以此把桶中的元素合并，即排序好的数据
        2、属性
            1、时间复杂度：它的时间复杂度取决于每个桶使用的排序算法。所以最好的情况是n，最坏的情况是n²，
                平均复杂度为n+k，这里可以看成是用了计数排序，弄成了很多个桶了
            2、空间复杂度：需要额外的空间k，所以为n+k 
            3、稳定性：她是稳定的。因为，每次放入桶中，都是先进先出的模式，不会改变他们的相对位置
        3、其他
            1、一般使用十个桶放数据。桶里面的排序方式，一般是快速排序最好了

    10、基数排序
        1、原理
            1、对数组中元素的位进行操作，例如，123有个位，百位，千位
            2、准备十个桶，对应每个位的十个数字
            3、从个位开始，以次把数值放入对应的桶中，如123放入的是3号桶，45放入的是五号桶。第一轮排序之后，把桶中的数据以次放入原数组中
            4、同理操作十位，百位，千位。不足的地方用零补上。如12的百位没有，则放入0号桶。每操作一个位之后都要把数据放回原数组中
            5、遍历到数组中的最高位之后，对数组的排序就完成了
        2、属性
            1、时间复杂度：由于排序的原理，每次都是从个位开始到最高位，所以最好，最坏的时间复杂度都一样。即为：n*k。n表示遍历一遍数组的时长，k表示最高位数
            2、空间复杂度：需要额外的空间k，所以为n+k。 
            3、稳定性：她是稳定的。因为，每次放入桶中，都是先进先出的模式，不会改变他们的相对位置
        3、其他
            1、由于需要额外的空间，当待排序数据过大时，每操作一位之后，都需要复制一次，导致大部分时长浪费在这里。但是总体而言，平均排序时长略小于快速排序

2020.04.07
    待添加点（四月份需完成）：
        1、目前很多排序只支持正数排序，而不支持负数排序。所以需要添加负数排序
        2、所有的算法都是从小到大排序，需要优化，并且支持从大到小排序，最好是做成接口配置的形式
        3、删减显示部分的代码，做成接口的形式，例如，我需要快速排序，就直接把此部分复制过去，而不需要改动任何东西。

